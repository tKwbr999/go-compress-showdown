# Go言語 圧縮アルゴリズム パフォーマンス比較計画

## 目的

Go言語の標準パッケージおよび主要なサードパーティライブラリを使用し、Gzip, Brotli, Zstandard の圧縮パフォーマンス（速度、圧縮率、リソース使用量）を比較・評価する。特に、生成AIレスポンスのようなテキストデータの処理を想定したベンチマークを行う。

## フェーズ概要

```mermaid
graph TD
    subgraph フェーズ1: 基盤構築
        A[Goプロジェクト初期化] --> B(HTTPサーバー実装);
        B --> C{圧縮ハンドラー実装};
        C -- Gzip --> C1(compress/gzip);
        C -- Brotli --> C2(andybalholm/brotli);
        C -- Zstandard --> C3(klauspost/compress/zstd);
        C1 & C2 & C3 --> D(Go標準ベンチマーク実装);
        D --> E(基本性能測定);
    end

    subgraph フェーズ2: データ準備
        F[初期データ準備] --> G(データ読み込み実装);
        G --> H(段階的データ拡充);
    end

    subgraph フェーズ3: vegeta テスト (詳細)
        I[vegetaインストール] --> J(テストシナリオ作成<br>- 固定レート<br>- 最大スループット);
        J --> K(HTTPサーバー起動);
        K --> L(vegeta実行<br>- 全組み合わせ);
        L --> M(vegetaレポート生成);
        K --> M1(サーバーリソース監視);
    end

    subgraph フェーズ4: 結果分析・考察
        N[全結果集約] --> O(結果比較・可視化);
        O --> P(考察);
    end

    E --> N;
    H --> L;
    M & M1 --> N;

    style J fill:#cfc,stroke:#333,stroke-width:2px
    style L fill:#cfc,stroke:#333,stroke-width:2px
```

## 各フェーズの詳細

### フェーズ1: 基盤構築

1.  **Goプロジェクト初期化:** `go mod init` を実行し、プロジェクトの依存関係管理を開始します。
2.  **HTTPサーバー実装:**
    *   `net/http` パッケージを使用し、基本的なHTTPサーバーを構築します。
    *   以下のエンドポイントをルーティングします。
        *   `/none?data=[small|medium|large]`
        *   `/gzip?level=[speed|default|best]&data=[small|medium|large]`
        *   `/brotli?level=[1|6|11]&data=[small|medium|large]`
        *   `/zstd?level=[fastest|default|best]&data=[small|medium|large]`
3.  **圧縮ハンドラー実装:**
    *   各エンドポイントに対応するハンドラーを実装します。
    *   リクエストされた圧縮アルゴリズムとレベルに基づき、レスポンスボディを圧縮します。
    *   `Content-Encoding` ヘッダーを適切に設定します。
    *   使用ライブラリ:
        *   Gzip: `compress/gzip`
        *   Brotli: `github.com/andybalholm/brotli`
        *   Zstandard: `github.com/klauspost/compress/zstd`
4.  **Go標準ベンチマーク実装:**
    *   `testing` パッケージを使用し、各圧縮アルゴリズムの純粋な圧縮・解凍処理速度とメモリ使用量を測定するベンチマーク関数 (`BenchmarkXxx`) を実装します。
    *   異なる圧縮レベル、異なるデータサイズでベンチマークを実行します。
5.  **基本性能測定:** 作成したベンチマークを実行し、初期の性能データを取得します (ns/op, B/op, allocs/op)。

### フェーズ2: データ準備

1.  **初期データ準備:**
    *   簡単な固定文字列。
    *   小規模なサンプルテキストファイル (例: `README.md`, `ai-response-optimization.md` の一部)。
2.  **データ読み込み実装:** HTTPハンドラーが、リクエストパラメータ (`data=...`) に応じて適切なテストデータを読み込めるように実装します。データはメモリ上に保持するか、都度ファイルから読み込むかを検討します。
3.  **段階的データ拡充:**
    *   中規模テキストファイル (例: 100KB程度)。
    *   大規模テキストファイル (例: 1MB程度)。
    *   必要に応じて、JSON形式のデータや、より生成AIの出力に近い形式のデータも追加します。

### フェーズ3: `vegeta` テスト (詳細)

1.  **`vegeta` インストール:** `go install github.com/tsenart/vegeta/v12@latest` 等で `vegeta` をインストールします。
2.  **テストシナリオ作成:**
    *   **目的:** HTTPレベルでのレイテンシ、スループット、サーバー負荷への影響評価。
    *   **対象:** 各圧縮アルゴリズム/レベル × 各データサイズのエンドポイント。
    *   **シナリオ1: 固定レートテスト**
        *   目的: 特定負荷下での安定レイテンシ測定。
        *   方法: 中程度の固定レート (例: 100rps) で一定時間 (例: 30s) 実行。
        *   指標: 平均/パーセンタイルレイテンシ、成功率。
        *   コマンド例: `echo "GET http://localhost:8080/gzip?level=speed&data=medium" | vegeta attack -rate=100 -duration=30s`
    *   **シナリオ2: 最大スループットテスト**
        *   目的: 処理可能な最大リクエストレート測定。
        *   方法: 一定時間、最大レート (`-rate=0`) で実行。
        *   指標: スループット、成功率、レイテンシ分布。
        *   コマンド例: `echo "GET http://localhost:8080/brotli?level=6&data=large" | vegeta attack -rate=0 -duration=30s`
3.  **HTTPサーバー起動:** ベンチマーク対象のHTTPサーバーを起動します。
4.  **`vegeta` 実行:** 作成したシナリオに基づき、全組み合わせのテストを実行します。結果は `tee results.bin` などで保存します。
5.  **`vegeta` レポート生成:** `vegeta report results.bin` で各テスト結果のレポートを生成・確認します。
6.  **サーバーリソース監視:** `vegeta` 実行中に、サーバー側のCPU使用率、メモリ使用量を監視します (`pprof`, `top`, `htop` 等)。

### フェーズ4: 結果分析・考察

1.  **全結果集約:**
    *   Go標準ベンチマークの結果 (速度, メモリ)。
    *   `vegeta` レポートの結果 (レイテンシ, スループット, 成功率)。
    *   各テストケースにおける圧縮率 (レスポンスサイズから算出)。
    *   サーバーリソース監視の結果 (CPU, メモリ)。
2.  **結果比較・可視化:** 収集したデータを表やグラフにまとめ、アルゴリズム、レベル、データサイズごとの性能差を可視化します。
3.  **考察:**
    *   各圧縮アルゴリズムの性能特性（速度 vs 圧縮率 vs リソース消費）を分析します。
    *   データサイズや圧縮レベルがパフォーマンスに与える影響を考察します。
    *   生成AIレスポンス処理というユースケースにおいて、どのアルゴリズム/レベルが最適かを結論付けます。

## 今後の拡張案

*   ストリーミング形式での圧縮比較実装とテスト。
*   クライアント側の解凍パフォーマンス測定。
*   `pprof` を用いた詳細なプロファイリングとボトルネック特定。